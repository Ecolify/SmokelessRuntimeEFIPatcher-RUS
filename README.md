# SREP на Русском
Копия утилиты за авторством SmokelessCPU, но с маленьким дополнением.

# В чем разница в сравнении с оригиналом
* Написал несколько комментариев в файлах исх. кода.
* Появился Рус перевод для сообщений на экране и в логе, вывод в лог был приспособлен для кодировки Unicode. Сами сообщения учащены, чтобы прогресс выполнения лучше отслеживался, и у пользователя не возникало мысли что программа зависла.
  </br>Переключение на Анг доступно через аргумент ENG (например, "SREP.efi ENG"). Но, как можно догадаться, тогда вызов SREP нужно осуществить через командную строку в Shell. Передавать ENG в .nsh разрешается
  </br>Либо можно скомпилировать патчер заново при BOOLEAN ENG = TRUE.
* Добавил 3 новые команды: LoadGUIDandSavePE, NonamePE, NonameFREEFORM.
  </br>Могут быть полезны для применения в особых случаях. В каких - будет далее.

# Как использовать
* Скомпильте исп. файл сами, найдите его у кого-нибудь в комьюнити или загрузите со страницы релизов. Текущая версия - 0.1.5.
* Распакуйте файл на накопитель и сделайте его загрузочным.
* Создайте новый или скопируйте готовый конфиг в корень.
* Запустите.

# Синтаксис для каждой из новых команд (с примерами)
Операция в "<...>" опциональна.

    Op OpName
        GUID
    <Op Patch>
        Argument 1
        Argument 2
        Argument 3
    End
    
    #Если драйвер ещё не в памяти, применена команда LoadGUIDandSavePE.
    <Op Exec>

### Значение

    OpName : LoadGUIDandSavePE, NonamePE, NonameFREEFORM
    GUID : GUID драйвера для поиска
    Argument 1 : OFFSET, PATTERN, REL_NEG_OFFSET, REL_POS_OFFSET
    Argument 2 : Модификатор для Argument 1
    Argument 3 : Буфер
    
# Добавленные команды
## LoadGUIDandSavePE
Загружает PE секцию модуля из FV по GUID. Применимо когда у модуля нет имени. Редко для патчей, так как в память загружается вторая копия модуля.
</br>Т.е. команда нужна для особых случаев когда у App, запуск которого инициирует вход в биос, нет секции UI.
</br>Что делает команду менее бесполезной это сохранение PE секции модуля как файл на флешку. Может быть применимо когда ни один способ дампа не работает.
</br>Формат GUID как в UEFiTool.

    Op LoadGUIDandSavePE
    FE3542FE-C1D3-4EF8-657C-8048606FF670

## NonamePE, NonameFREEFORM
Используют одну и ту-же функцию, с различием в лишь одном передаваемом значении.

* NonamePE - ищет секцию PE по GUID;
* NonameFREEFORM - ищет секцию Freeform по GUID (даже если сжата lzma).
</br>Синтаксис как у LoadGUIDandSavePE, но у этих команд область поиска RAM, вместо FV.

Работает таким образом, что сначала находится модуль в FV, но не RAM, соотв. введенному GUID. Вместо имени этого модуля, в отдельную переменную кладется его размер. Затем создается массив из модулей уже попавших в RAM. И размер каждого из этих модулей сравнивается с сохраненным значением, в упомянутой отдельной переменной. При совпадении цикл сравнения останавливается, функция возвращает ImageInfo текущего модуля.

В этом подходе есть недостаток, при котором **в случае наличия модулей одинакового размера, будет выбран первый по порядку**.

# Todos

    [ ] Regex Matching

Было бы круто добавить SREP умение обращаться с абстрактным знаками. Но, как ясно из [строки 400](https://github.com/Maxinator500/SmokelessRuntimeEFIPatcher-RUS/blob/24d1d5ef25612d2aa14955be1205675b91bbc606/SmokelessRuntimeEFIPatcher/Utility.c#L402) в Utility, я уже попытался реализовать это с портированной EDK2 библиотекой Oniguruma. Не найдя примеров использования в интернете, попытавшись вызвать функцию как понял из описания, SREP зависает на моменте её вызова... Даже если вместо сложных переменных даю на сравнение две болванки одинакового текста.
</br>Приветствую Pull по этому делу!
